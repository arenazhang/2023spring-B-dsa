程序和算法的区别：

算法是对问题解决的分布描述

程序是采用编程语言实现的算法，同一个算法能通过不同的编程语言产生很多程序

算法分析的角度：更高效利用计算资源

**算法的基本特性 ：**

有穷性：算法经过有限步以后结束

确定性：算法的下一步必须是明确的

可行性（正确性、可执行性）：每一步都可行，且最终是正确的

**程序 = 算法 + 数据结构**

主要区别在于：有穷性、确定

世界上最早的算法：欧几里得算法（辗转相除法求最大公约数）

需要步骤：不会超过较小数的位数的五倍

![image-20240618113627255](C:\Users\ARENA TANG\AppData\Roaming\Typora\typora-user-images\image-20240618113627255.png)

**数据结构的定义**：按照逻辑关系组织起来的一批数据, 按一定的存储结构把它存储在计算机中, 并在这些数据上定义了相关运算的集合。

**数据结构三要素**：

逻辑结构: 定义了结构中的基本元素之间的相互关系。

数据元素之间的逻辑关系；二元组 (D, R)，其中 D 是数据元素的有

限集合，R 是 D 上的关系的有限集。

存储结构: 给出了结构中的基本元素之间的存储方式

包括元素的表示和关系的表示。

数据的运算: 这个结构具有的行为特征

体现为在存储结构上的具体实现算法。

**数据的逻辑结构：**描述了数据元素之间的逻辑关系，以及对这些关系的操作。**它不涉及具体的存储细节，而是关注数据元素之间的关联和组织方式**。通常要求同一逻辑结构中的所有数据元素具有相同的特性，这意味着不仅数据元素所包含的数据项的个数要相同，而且对应数据项的类型要一致 

集合：数据元素仅仅“同属于一个集合”，而没有其他关系

线性结构：数据元素之间仅存在一对一的关系（唯一后继、唯一前驱）

树形结构：数据元素之间存在一对多的关系（层状结构，唯一前驱，多个后继）

图状或网状结构：数据元素之间存在多对多的关系，元素之间的关系是任意的（多个前驱，多个后继）

包含关系：集合 ⊂ 线性结构 ⊂ 树形结构 ⊂ 图状或网状结构

**存储结构：**存储结构描述了数据在计算机内部的实际存储方式。它主要关注数据在计算机内存中的组织形式，以及如何在内存中存储和访问数据

顺序存储结构：把逻辑上相邻的结点存储在物理位置相邻的存储单元里，结点间的逻辑关系由存储单元的邻接关系来体现。（如列表）

特点：访问方式是*随机访问*，每个节点大小相同，可以得出任意节点的位置

链式存储结构：不要求逻辑上相邻的结点在物理位置上亦相邻，结点间的逻辑关系是由附加的指针字段表示的。（如链表）

特点：①不要求物理位置相邻，结点间的逻辑关系是由附加的指针字段表示的 ②给结点分配的存储空间可以是连续的，也可以是不连续的③访问方式:顺序访问，需要顺着链表进行

索引存储结构：除建立存储结点信息外，还建立附加的索引表来标识结点的地址。（如字典）

特点：①在主表存储结点信息之外，还有附加的索引表 (也叫目录表) 来标识结点的地址。②key 由结点的属性生成，索引表可以有多个

散列存储结构：就是根据结点的关键字直接计算出该结点的存储地址。（如散列表）

举例：如用对11的mod来哈希存储一系列数，mod相同的数字存在同一个哈希值的表内，有冲突的元素可以插在表尾也可以插在表头

![](media/image1.png)

**大O表示法和常见算法的时间复杂度**

度量标准：赋值语句

数量级函数O（n）描述了随着n增加而*增加速度最快的主导部分*

具体数据也会影响算法运行时间：分为最好、最差、平均情况，平均状况体现了算法的主流性能

![](media/image2.png)

O（n）：线性

**线性表**

**定义：**0个或多个数据元素的有限序列。

线性表的数据集合为{a{1},a{2}……a\_{n}}，有唯一的头元素和尾元素，除了头元素外，每个元素都有唯一的前驱元素，除了尾元素外，每个元素都有唯一的后继元素。

线性表中的元素属于相同的数据类型，即每个元素所占的空间相同。

![](media/image3.png)

**1.顺序表**

python中的顺序表就是列表，元素在内存中连续存放，每个元素都有唯一序号(下标），且根据序号访问（包括读取和修改）元素的时间复杂度是O(1)的（随机访问）。

2.  **链表**

    ①单链表

    在链式结构中，除了要存储数据元素的信息外，还要存储它的后继元素的存储地址。

    因此，为了表示每个数据元素a{i}与其直接后继元素a{i+1}之间的逻辑关系，对数据a{i}来说，除了存储其本身的信息之外，还需要存储一个指示其直接后继的信息（即直接后继的存储位置）。存储数据元素信息的域称为数据域，存储直接后继位置的域称为指针域。指针域中存储的信息称做指针或链。这两部分信息组成数据元素a{i}的存储映像，称为结点（Node）。

    链表中第一个结点的存储位置叫做*头指针*。有时为了方便对对链表进行操作，会在单链表的第一个结点前*附设一个节点*，称为头结点，此时头指针指向的结点就是头结点。

    ![](media/image4.png)

    ②双向循环链表：增加一个前驱指针

    ③循环链表：将单链表中终端节点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表。

    然而这样会导致访问最后一个结点时需要O(n)的时间，所以我们可以写出仅设尾指针的循环链表。

    仅设置尾指针的循环链表：查找O（n），删除O(n)，插入O(1)

**线性表的时间复杂度：**

生成、求表中元素个数、表尾添加/删除元素、返回/修改对应下标元素，均为O(1)；

查找、删除、插入元素，均为O(n)。

**线性表的优缺点：**

优点：1、*无须*为表中元素之间的*逻辑关系*而增加额外的*存储空间*；

2、可以快速的存取表中*任一位置*的元素。

缺点：1、插入和删除操作需要*移动大量元素*；

2、当线性表长度较大时，难以确定存储空间的容量；

3、造成存储空间的“碎片”。

**排序**

**1.冒泡排序**

原理：相邻项比较，如果左边比右边大就交换位置，每一轮都将下一个最大值放到正确的位置上。

列表有n个元素：

第1轮比较n-1对，第x轮比较n-x对，一共比较n-1轮

总比较次数：从（n-1）一直加到1，∴*时间复杂度：O(N2)；空间复杂度O(1)*

是否稳定排序：是

特别地，如果一轮中没有发生交换，则说明此时已经完全排好序，可以break——短冒泡算法

**2.选择排序**

原理：每次遍历全列表找出最大值，并在遍历完后放到正确的位置上

列表有n个元素：

一共比较n-1轮

*时间复杂度：O(N2)*，和冒泡排序的比较次数相同;空间复杂度O(1)

特点：因为减少了交换次数，因此比冒泡排序快

**3.插入排序**

原理：在列表较低的一端维护一个有序的子列表，并逐个将每个新元素“插入”这个子列表，每次都要遍历子列表找出插入的正确位置（从右往左，把比它大的元素右移动，遇到一个比它小的/到达终点就插入）

列表有n个元素：共比较n-1轮

第一轮比较1次，第x轮比较x次

*时间复杂度：O（N2）,比较次数与冒泡排序相同；空间复杂度O(1)*

列表已经有序（最好情况下）：每轮只需要比较一次

交换和移动的耗时区别：移动操作和交换操作有一个重要的不同点。总体来说，交换操作的处理时间大约是移动操作的 3 倍，因为后者只需进行一次赋值。

**4.希尔排序：插入排序的改进**

原理：将列表按照步长分割为子列表，每个子列表内部进行插入排序，再对整体列表进行插入排序。

![IMG_256](media/image5.png)

![](media/image6.png)

时间复杂度：介于O(N)~O(N2)之间，取决于算法的对象；空间复杂度：O(1)。

**5.归并排序：分治策略，递归算法**

原理：每次将一个列表一分为二，如果列表为空或者只有一个元素，那么就是有序的，再进行归并

核心：归并的操作，将两个小的有序列表合成一个大的有序列表，每次从有序列表中取出最小值，放回初始列表

列表有n个元素：

可以切分log2N次，归并操作需要比较n次，∴需要进行logn次拆分，每次进行n次操作

*时间复杂度：O（NlogN）*

特点:会占用额外的存储空间:空间复杂度O(n)

**6.快速排序：分治策略**

原理：

①基准值：默认选取列表第一个元素，基准值的位置被成为分割点

②分区操作：分区操作首先找到两个坐标——leftmark 和 rightmark——它们分别位于列表剩余元素的开头和末尾

首先加大 leftmark，直到遇到一个大于基准值的元素。然后减小 rightmark，直到遇到一个小于基准值的元素。这样一来，就找到两个与最终的分割点错序的元素。本例中，这两个元素就是 93 和 20。互换这两个元素的位置，然后重复上述过程。

当 rightmark 小于 leftmark 时，过程终止。此时，rightmark 的位置就是分割点。将基准值与当前位于分割点的元素互换，即可使基准值位于正确位置。

分割点左边的所有元素都小于基准值，右边的所有元素都大于基准值。因此，可以在分割点处将列表一分为二，并针对左右两部分递归调用快速排序函数。

![IMG_257](media/image7.png)

![](media/image8.png)

时间复杂度：

*如果分区操作总是发生在列表中部：O(NlogN)*

分割点偏向某一端（最坏情况，切割不均匀）：有可能分为1与n-1，1与n-2...最大时间复杂度O(N2)

空间复杂度：考虑递归堆栈，为O(n)，不考虑则为O(1)。

避免方式：三数取中法，即即在选择基准值时考虑列表的头元素、中间元素与尾元素，取中间值作为基准值

7. 堆排序

堆排序是一种基于完全二叉树（堆）的排序算法。它通过将待排序的元素构建成一个堆，然后利用堆的性质来实现排序。在堆中，每个结点的值都必须大于等于其子结点的值。

时间复杂度：O(nlogn)；空间复杂度：O(1)。

堆排序适合处理大型数据集，采取原地排序，但不稳定，因为可能会交换相同元素。

```python
def heapify(arr, n, i):
    """
    将以节点 i 为根的子树调整为最大堆。

    Args:
    - arr: 待排序的数组
    - n: 数组长度
    - i: 当前子树的根节点索引
    """
    largest = i  # 初始化根节点索引为最大值索引
    l = 2 * i + 1  # 左子节点索引
    r = 2 * i + 2  # 右子节点索引

    # 如果左子节点存在并且大于根节点，则更新最大值索引
    if l < n and arr[l] > arr[largest]:
        largest = l

    # 如果右子节点存在并且大于当前最大值节点，则更新最大值索引
    if r < n and arr[r] > arr[largest]:
        largest = r

    # 如果最大值索引不等于当前节点索引，则交换当前节点与最大值节点，并递归调整下面的子树
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)

def heapsort(arr):
    """
    堆排序函数，首先建立最大堆，然后依次取出堆顶元素（最大值），并调整剩余的元素为最大堆。

    Args:
    - arr: 待排序的数组
    """
    n = len(arr)

    # 构建最大堆，从最后一个非叶子节点开始向上调整
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    # 依次取出堆顶元素（最大值），并重新调整剩余元素为最大堆
    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]  # 将当前最大值交换到数组末尾
        heapify(arr, i, 0)  # 调整剩余的元素为最大堆

```

8.基数排序

​	基数排序是一种非比较性的整数排序算法，它根据键值的每位数字来进行排序。基数排序的核心思想是将待排序的元素按照位数切割成不同的数字，然后按照这些位数分别进行排序。这种排序算法属于分配式排序，它的性能取决于桶的使用方法。(先排各位，再排十位，再排百位，以此类推)

​	时间复杂度：$$O(d*(n+k))$$，空间复杂度：$$O(n+k)$$。(n) 是数组长度， (k) 是基数（这里是 10，因为是十进制）

​	基数排序不依赖于比较操作，适用于整数等固定长度的数据类型，并且在某些情况下具有稳定性。但它需要额外的空间，而且对于位数较大的数据可能不太实用

```python
def radix_sort(arr):
    # 找到数组中的最大值，确定最大位数
    max_num = max(arr)
    max_length = len(str(max_num))

    # 创建 10 个空桶
    buckets = [[] for _ in range(10)]

    # 根据位数进行排序
    for digit in range(max_length):
        # 将数组中的数字分配到相应的桶中
        for num in arr:
            bucket_idx = (num // 10**digit) % 10  # 确定当前位数上的数字
            buckets[bucket_idx].append(num)

        # 按照当前位数上的数字顺序重组数组
        arr = [num for bucket in buckets for num in bucket]

        # 清空桶，为下一次位数排序做准备
        buckets = [[] for _ in range(10)]

    return arr

```

![IMG_258](media/image9.png)



最坏情况下：

除了归并和堆排序

其他最坏情况都是O(N2)



## **树：**

### 相关概念：

二叉树的的元素称为“结点”。结点由三部分组成：数据、左子结点指针、右子结点指针。

高度、深度都默认是边的个数，根节点高度为0

结点的度(degree)：结点的非空子树数目。也可以说是结点的子结点数目。

叶结点(leaf node)：度为0的结点。

分支结点：度不为0的结点。即除叶子以外的其他结点。也叫内部结点。

兄弟结点(sibling)：父结点相同的两个结点，互为兄弟结点。结点的层次(level)：树根是第0层的。如果一个结点是第n层的，则其子结点就是第n+1层的。结点的深度(depth)：即结点的层次。

特殊的树和性质：

完美二叉树：每一层结点数目都达到最大。即第i层有2i个结点。高为h的完美二叉树，     有2h+1 -1个结点

满二叉树：没有1度结点的二叉树

完全二叉树：除最后一层外，其余层的结点数目均达到最大。而且，最后一层结点若不满，则缺的结点定是在最右边的连续若干个

![image-20240617234215284](C:\Users\ARENA TANG\AppData\Roaming\Typora\typora-user-images\image-20240617234215284.png)

二叉树的性质：

![image-20240617234128714](C:\Users\ARENA TANG\AppData\Roaming\Typora\typora-user-images\image-20240617234128714.png)

二叉树的遍历：

特殊方法：前序=在左侧画圈，中序=在下侧画圈，后序=在右侧画圈

```python
#前序遍历
def preorder(node):
    print(self.value)
    if self.left:
        preorder(self.left)
    if self.right:
        preorder(self.right)
#后续遍历：
def postorder(node):
    if self.left:
        postorder(self.left)
    if self.right:
        postorder(self.right)
    print(self.value)
#按层次遍历：（队列表达式例题）
def level_order_traversal(root):
    queue = [root]
    traversal = []
    while queue:
        node = queue.pop(0)
        traversal.append(node.value)
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)
    return traversal
#这段代码通过队列实现了层序遍历的逻辑，确保了按照每一层从左到右的顺序访问树的所有节点。
#中序遍历：
def inorder(root):
    result=[]
    if root is not None:
        result+=postorder(root.left)
        result+=[root.val]
        result+=postorder(root.right)
    return result
```

![image-20240617234311897](C:\Users\ARENA TANG\AppData\Roaming\Typora\typora-user-images\image-20240617234311897.png)

给出中序+前序/后序才可以建树

方法：

![image-20240617234438390](C:\Users\ARENA TANG\AppData\Roaming\Typora\typora-user-images\image-20240617234438390.png)

哈夫曼树（最优二叉树）（不唯一）：

![image-20240617235815406](C:\Users\ARENA TANG\AppData\Roaming\Typora\typora-user-images\image-20240617235815406.png)

WPL计算：每个节点的权值*树根到该节点的路径长度

哈夫曼编码树（不唯一）：

基本思想：使用频率越高的字符，离树根越近。构造过程和最优二叉树一样

![image-20240618000210358](C:\Users\ARENA TANG\AppData\Roaming\Typora\typora-user-images\image-20240618000210358.png)

如何快速地在结点集合取出权值最小的两个结点：不要O(n)的笨办法。用"堆"，可以做到O(log(n))

![image-20240618000058116](C:\Users\ARENA TANG\AppData\Roaming\Typora\typora-user-images\image-20240618000058116.png)

编码结果：左边的边设为0，右边的边设为1，则从根节点走到叶子节点的结果就是该节点的哈夫曼编码，保证最终的编码最短

![image-20240618000906832](C:\Users\ARENA TANG\AppData\Roaming\Typora\typora-user-images\image-20240618000906832.png)

#### 二叉搜索树（Binary Search Tree，BST）：

1. 节点的左子树中的所有节点的值小于该节点的值。

2. 节点的右子树中的所有节点的值大于该节点的值。

3. 左子树和右子树也必须是二叉搜索树。

   相关性质：

   二叉搜索树的插入：从上往下找直到子节点为None再插入即可

   二叉搜索树的删除：

   为叶子节点：直接删除

   只有左子树/右子树：删除后把子树接到父节点即可

   否则：找到该节点左子树中最大的/右子树中最小的节点，将其代替原有节点，最后删除该节点

   特别的，二叉搜索树的中序遍历就是从小到大的顺序

   平衡的前提下：

   1. **搜索（Search）**：在平衡的二叉搜索树上搜索一个元素的平均时间复杂度为 ( O(\log n) )，其中 ( n ) 是树中节点的数量。最坏情况下可能退化到 ( O(n) )，例如树高度为 ( n ) 的链表。
   2. **插入（Insert）**：在平衡的二叉搜索树中插入一个元素的平均时间复杂度为 ( O(\log n) )，最坏情况下为 ( O(n) )。
   3. **删除（Delete）**：在平衡的二叉搜索树中删除一个元素的平均时间复杂度为 ( O(\log n) )，最坏情况下为 ( O(n) )。

树和森林：

![image-20240618112241385](C:\Users\ARENA TANG\AppData\Roaming\Typora\typora-user-images\image-20240618112241385.png)

![image-20240618112307087](C:\Users\ARENA TANG\AppData\Roaming\Typora\typora-user-images\image-20240618112307087.png)

把树转换为二叉树：核心方法：左儿子右兄弟

把所有兄弟之间都连线，然后删掉父节点除了最左边节点的其他节点的连线，再进行调整（兄弟相连留长子，转45°）

把二叉树转换为普通树：逆过程

原理：每有一个左节点就代表有一层新的树，所有的右节点都是最左节点的兄弟

森林：不相交的树的集合，有顺序之分（第一颗、第二棵）

![image-20240618112629113](C:\Users\ARENA TANG\AppData\Roaming\Typora\typora-user-images\image-20240618112629113.png)

![image-20240618113513078](C:\Users\ARENA TANG\AppData\Roaming\Typora\typora-user-images\image-20240618113513078.png)

森林转换为二叉树：

①将每一棵树都转换为二叉树

②根节点相连、调整

![image-20240618113124820](C:\Users\ARENA TANG\AppData\Roaming\Typora\typora-user-images\image-20240618113124820.png)

二叉树转森林：去掉全部右孩线，孤立二叉再还原

去掉右孩子等于把森林里的每棵树分开，然后再分别使用二叉树转化为树的方法即可

![image-20240618114902330](C:\Users\ARENA TANG\AppData\Roaming\Typora\typora-user-images\image-20240618114902330.png)

![image-20240618114958456](C:\Users\ARENA TANG\AppData\Roaming\Typora\typora-user-images\image-20240618114958456.png)

## 图论相关内容：

### 图的相关概念：

 路径的长度：路径上的边的数目

顶点的度数：和顶点相连的边的数目。

简单路径：除了起点和终点可能相同外，其它顶点都不相同的路径

完全图：

完全无向图：任意两个顶点都有边相连;

完全有向图：任意两个顶点都有两条方向相反的边

连通：如果存在从顶点u到顶点v的路径，则称u到v连通，或u可达v。无向图中，u可达v,必然v可达u。有向图中，u可达v，并不能说明v可达u。

连通无向图：图中任意两个顶点u和v互相可达。

强连通有向图：图中任意两个顶点u和v互相可达。

#有 n（n>=2）个顶点的有向强连通图最少有 _ _ _ _ _ 条边。n

子图：从图中抽取部分或全部边和点构成的图

连通分量（极大连通子图）：无向图的一个子图，是连通的，且再添加任何一些原图中的顶点和边，新子图都不再连通

强连通分量：有向图的一个子图，是强连通的，且再添加任何一些原图中的顶点和边，新子图都不再强连通。

网络：带权无向连通图

![image-20240618082519007](C:\Users\ARENA TANG\AppData\Roaming\Typora\typora-user-images\image-20240618082519007.png)

![image-20240618115224961](C:\Users\ARENA TANG\AppData\Roaming\Typora\typora-user-images\image-20240618115224961.png)

### 图的几种表示方法：

#### 1、直接存边

**方法**：

​	使用一个数组来存边，数组中的每个元素都包含一条边的起点与终点（带边权的图还包含边权）。（或者使用多个数组分别存起点，终点和边权）

**复杂度**：

​	查询是否存在某条边：$$O(m)$$。

​	遍历一个点的所有出边：$$O(m)$$。

​	遍历整张图：$$O(nm)$$。

​	空间复杂度：$$O(m)$$。

**应用**：

​	由于直接存边的遍历效率低下，一般不用于遍历图。

​	在$$Kruskal$$算法中，由于需要将边按边权排序，需要直接存边。

​	在有的题目中，需要多次建图（如建一遍原图，建一遍反图），此时既可以使用多个其它数据结构来同时存储多张图，也可以将边直接存下来，需要重新建图时利用直接存下的边来建图。

#### 2、邻接矩阵

**方法**：

​	使用一个二维数组$$graph$$来存边，其中$$graph[u][v]$$为$$1$$表示存在$$u$$到$$v$$的边，为$$0$$表示不存在。如果是带边权的图，可以在$$graph[u][v]$$中存储$$u$$到$$v$$的边的边权。

**复杂度**：

​	查询是否存在某条边：$$O(1)$$。

​	遍历一个点的所有出边：$$O(n)$$。

​	遍历整张图：$$O(n^2)$$。

​	空间复杂度：$$O(n^2)$$。

**应用**：

​	邻接矩阵只适用于没有重边（或重边可以忽略）的情况。

​	其最显著的优点是可以$$O(1)$$查询一条边是否存在。

​	n个顶点的图，需要一个有n2个元素的矩阵,比较费空间

​	查找和一个顶点的邻点，需要O(n)时间

​	对于边的数目只有O(n)量级的稀疏图，邻接矩阵既浪费空间也浪费时间,适用于边的数目达到O(n2)量级的稠密图

#### 3、邻接表

**方法**：

​	为了实现稀疏连接的图，更高效的方式是使用邻接表。在邻接表实现中，我们为图对象的所有顶点保存一个主列表，同时为每一个顶点对象都维护一个列表，其中记录了与它相连的顶点。

![image-20240618081648247](C:\Users\ARENA TANG\AppData\Roaming\Typora\typora-user-images\image-20240618081648247.png)

**复杂度**：

​	查询是否存在$$u$$到$$v$$的边：$$O(d^+(v))$$。（若排序，二分查找可以降低复杂度）

​	遍历点$$u$$的所有出边：$$O(d^+(v))$$。

​	遍历整张图：$$O(n+m)$$。

​	空间复杂度：$$O(m)$$。

**应用**：

​	存各种图都很适合，除非有特殊需求（如需要快速查询一条边是否存在，且点数较少，可以使用邻接矩阵）。

​	尤其适用于需要对一个点的所有出边进行排序的场合。

链表：

**复杂度**：

​	查询是否存在$$u$$到$$v$$的边：$$O(d^+(u))$$。

​	遍历点$$u$$的所有出边：$$O(d^+(u))$$。

​	遍历整张图：$$O(n+m)$$。

​	空间复杂度：$$O(m)$$。

**应用**：

​	存各种图都很适合，但不能快速查询一条边是否存在，也不能方便地对一个点的出边进行排序。

#### 4.链表（链式前向星）

插入和删除边的时间复杂度主要取决于顶点的度数，即与顶点相邻接的边的数量。

遍历邻接顶点的时间复杂度也与顶点的度数成正比。

插入、删除、遍历的时间复杂度为 ( O(d_u) )，其中 ( d_u ) 是顶点 ( u ) 的度数

### 图的遍历：

#### DFS深度优先搜索:

选一条路走到底再返回

![image-20240618082659266](C:\Users\ARENA TANG\AppData\Roaming\Typora\typora-user-images\image-20240618082659266.png)

应用：①寻找路径②寻找最短路径

#### BFS广度优先搜索：一圈一圈找

使用queue作为数据结构

![image-20240618082842170](C:\Users\ARENA TANG\AppData\Roaming\Typora\typora-user-images\image-20240618082842170.png)

#### 时间复杂度：

![image-20240618082917184](C:\Users\ARENA TANG\AppData\Roaming\Typora\typora-user-images\image-20240618082917184.png)

剪枝：在已知该路径不满足所求的时候及时停止继续搜索

可行性剪枝（该路径走不通）、最优性剪枝（比已知的最短路径长）

### 相关算法：

#### floyd算法：求任意两个点之间的最短路径

核心：使用邻接矩阵存储，依次将每个点作为必须经过的中间点对两个点之间的最短距离进行比较和更新，遍历完所有点作为中间点的情况，所得的邻接矩阵里面就是任意两点值最小的路径

![image-20240618005709087](C:\Users\ARENA TANG\AppData\Roaming\Typora\typora-user-images\image-20240618005709087.png)



#### Dijkstra算法：带权重的最小路径

（求一个点到其他所有点的最短路径）

原理：

1. **初始化**：选择一个起始节点作为源点，将源点到自身的距离初始化为0，将源点到其他所有节点的距离初始化为无穷大（或者一个很大的数），并将所有节点标记为未访问。
2. **迭代更新**：
   - 从未访问的节点中选择当前距离源点最近的节点（即当前距离最小的节点）作为当前节点。
   - 对于当前节点的每个相邻节点，计算通过当前节点到达相邻节点的距离，如果该距离小于已知的最短距离，则更新最短距离。
   - 将当前节点标记为已访问。
3. **重复步骤2**，直到所有节点都被标记为已访问或者如果剩余的未访问节点都是不可达的（此时它们的最短距离仍然是无穷大）。
4. **输出**：此时，每个节点的最短路径距离就已经确定。

时间复杂度：Dijkstra算法使用了贪心算法的思想，每次选择当前距离最小的节点进行更新，因此时间复杂度为 ( O((V + E) \log V) )，其中 ( V ) 是顶点数， ( E ) 是边数。这是因为每个节点可能会被更新到 ( V ) 次，而每次更新需要 ( O(\log V) ) 的时间复杂度来调整优先队列中的节点顺序。

最小生成树（MST）：它是一棵树，连接了图中的所有顶点，并且其所有边的权重之和最小。

**唯一性**：如果图的权重函数（边的权重）是唯一的，那么最小生成树也是唯一的。

#### 最小生成树及相关算法

- ##### **Prim算法**：基于贪心策略，从一个初始顶点开始，逐步添加新的顶点和边，保持当前生成树总是最小。

  ![image-20240603101623672](C:\Users\ARENA TANG\AppData\Roaming\Typora\typora-user-images\image-20240603101623672.png)

- **Kruskal算法**：基于并查集数据结构，首先将所有的边按权重排序，然后逐步添加最小权重的边，并且确保不形成环路，直到添加了 ( V-1 ) 条边为止（( V ) 是顶点数）。**不能有负权值边。**

- ![image-20240618003341490](C:\Users\ARENA TANG\AppData\Roaming\Typora\typora-user-images\image-20240618003341490.png)

  时间复杂度：

- **Prim算法**：使用最小堆实现时，时间复杂度为 ( O((V + E) \log V) )，其中 ( V ) 是顶点数， ( E ) 是边数。

- **Kruskal算法**：时间复杂度主要取决于边的排序和并查集操作，通常为 ( O(E \log E + E \log V) )，其中 ( E ) 是边数， ( V ) 是顶点数。

  已考知识点：
  
  如果各边权值各不相同，存在**唯一最小生成树**
  
  对任意一个连通的无向图，如果存在一个环，且这个环中的一条边的权值大于该环中任意一个其它的边的权值，那么这条边一定不会是该无向图的最小生成树中的边。

#### 拓扑排序

AOE网络并非只有一个入度为0的点，也并非只有一个出度为0的点。也可以为所有入度为0的点添加一个前驱点，为所有出度为0的点都添加一个后继点，边权都为0，则AOE网络变成起点终点唯一

![image-20240618084917984](C:\Users\ARENA TANG\AppData\Roaming\Typora\typora-user-images\image-20240618084917984.png)

![image-20240618085111842](C:\Users\ARENA TANG\AppData\Roaming\Typora\typora-user-images\image-20240618085111842.png)

算法思想：用于判断有向图是否存在回路，只适用于有向无环图

①选择一个入度为0的顶点并输出

②从图中删除入度为0的顶点指向别的顶点的边

③循环进行①②，循环结束时，若输出顶点数小于图中顶点数，则存在回路，否则不存在

其他判图常考思路：

***\*1.判断连通：\****

若DFS/BFS可以访问到所有顶点，或者并查集进行合并后所有顶点的祖先是同一个，则说明连通。

***\*2.\*******\*无向图判环：\****

若DFS/BFS访问某顶点的邻接点时显示该邻接点已被访问且不是当前顶点的父顶点，或者并查集进行合并过程中发现两个顶点在合并之前已经属于同一个集合，则说明有环。

求AOE最早发生时间：

![image-20240618085605567](C:\Users\ARENA TANG\AppData\Roaming\Typora\typora-user-images\image-20240618085605567.png)

求最晚发生时间：

![image-20240618085625429](C:\Users\ARENA TANG\AppData\Roaming\Typora\typora-user-images\image-20240618085625429.png)

##### 判断有向图是否强连通： Kosaraju's 算法函数

核心：两次dfs

作用：用于查找有向图中强连通分量的算法。强连通分量是指在有向图中，任意两个节点都可以相互到达的一组节点。

## 字符串KMP匹配算法

字符串概念：串是一种特殊的线性表，其特殊性体现在数据元素是一个字符,串是字符的有限序列,模式匹配是串的一种重要运算,串既可以采用顺序存储，也可以采用链式存储 

暴力匹配：一一比对，一个不一样就从头开始遍历

时间复杂度：O(N*M),N和M分别表示主串和子串的长度

KMP算法：线性复杂度O（N+M）

核心：在主串上的指针i永远不后退，这是线性复杂度的来由

前缀：包含第一个字母但不包含最后一个字母

后缀：包含最后一个字母但不包含第一个

1.求next数组

```python

compute_lps 函数用于计算模式字符串的LPS表。LPS表是一个数组，
其中的每个元素表示模式字符串中当前位置之前的子串的最长前缀后缀的长度。
该函数使用了两个指针 length 和 i，从模式字符串的第二个字符开始遍历。
def compute_lps(pattern):
  
    计算pattern字符串的最长前缀后缀（Longest Proper Prefix which is also Suffix）表
    :param pattern: 模式字符串
    :return: lps表

    m = len(pattern)
    lps = [0] * m
    length = 0
    for i in range(1, m):
        while length > 0 and pattern[i] != pattern[length]:
            length = lps[length - 1]    # 跳过前面已经比较过的部分
        if pattern[i] == pattern[length]:
            length += 1
        lps[i] = length
    return lps
```

前两个：无脑填0和1

原理：按照前一个字母的数值进行前后缀画圈匹配，如果不匹配就依次减小直到匹配or为0，再把这个值+1作为当前字母的值，若出现前面没出现过的字母则标为0，再继续

![image-20240618103245702](C:\Users\ARENA TANG\AppData\Roaming\Typora\typora-user-images\image-20240618103245702.png)

求完next数组后：i和j双指针向前移动，i在主串上，j在参考串上，当遇到i与j不同的时候就去看最后一个匹配成功的字母的next对应值，表示可以跳过的字串的个数，比如next如果是2就表示可以把j移到参考串上的第三个字母进行继续匹配

### 其他边角知识点：

ADT（Abstract Data Type，抽象数据类型）是一种数学模型或数据结构的概念，它定义了一组操作的接口及其语义约束，而不指定这些操作如何在计算机中实现。

1. **示例**：常见的抽象数据类型包括栈（Stack）、队列（Queue）、链表（LinkedList）、树（Tree）、图（Graph）等，它们都定义了一组操作，但可以用多种不同的方式来实现。
2. 特点：抽象性、接口和操作、实现的独立性

### 二分查找（折半查找）

![image-20240618110306261](C:\Users\ARENA TANG\AppData\Roaming\Typora\typora-user-images\image-20240618110306261.png)

![image-20240618110342031](C:\Users\ARENA TANG\AppData\Roaming\Typora\typora-user-images\image-20240618110342031.png)

![image-20240618110435261](C:\Users\ARENA TANG\AppData\Roaming\Typora\typora-user-images\image-20240618110435261.png)

具体步骤如下：

1. 首先，确定数组的中间元素。
2. 将目标值与中间元素进行比较。
3. 如果目标值等于中间元素，则找到了目标，返回其位置。
4. 如果目标值小于中间元素，则在数组的左半部分继续查找。
5. 如果目标值大于中间元素，则在数组的右半部分继续查找。
6. 重复以上步骤，直到找到目标值或确定目标值不在数组中。

折半查找是一种高效的查找算法，其时间复杂度为 O(log n)，其中 n 是数组的长度。由于每次都能将查找范围减半，因此相比于线性查找（O(n)时间复杂度），折半查找在大型有序数组中能显著减少查找时间。然而，折半查找要求数组是有序的，否则无法保证其正确性。

### 散列表：

![image-20240618122636409](C:\Users\ARENA TANG\AppData\Roaming\Typora\typora-user-images\image-20240618122636409.png)

**处理散列表冲突**的常⻅⽅法包括以下⼏种：

1. 链地址法（Chaining）：使⽤链表来处理冲突。每个散列桶（哈希桶）中存储⼀个链表，具有相同散列值的元素会链接在同⼀个链表上。

2. 开放地址法（Open Addressing）：

线性探测（Linear Probing）：如果发⽣冲突，就线性地探测下⼀个可⽤的槽位，直到找到⼀个空槽位或者达到散列表的末尾。

缺点：会使散列表中的元素出现聚集现象

⼆次探测（Quadratic Probing）：如果发⽣冲突，就使⽤⼆次探测来查找下⼀个可⽤的槽位，避免线性探测中的聚集效应。

双重散列（Double Hashing）：如果发⽣冲突，就使⽤第⼆个散列函数来计算下⼀个槽位的位置，直到找到⼀个空槽位或者达到散列表的末尾。

3. 再散列（Rehashing）：当散列表的**装载因⼦（****load factor****）**超过⼀定阈值时，进⾏扩容操作，重新调整散列函数和散列桶的数量，以减少冲突的概率。

4. 建⽴公共溢出区（Public Overflow Area）：将冲突的元素存储在⼀个公共的溢出区域，⽽不是在散列桶中。在进⾏查找时，需要遍历溢出区域。

   **影响散列表效率的因素：**

   1. **哈希函数的质量**：哈希函数决定了键（key）如何映射到散列表中的位置。一个好的哈希函数能够将键均匀地分布在散列表中，避免或最小化碰撞（collision）（即多个键映射到同一个位置）。

   2. **装载因子**：装载因子是指散列表中已存储的键值对数目与散列表大小的比率。装载因子过高会增加碰撞的可能性，降低散列表的效率。

   3. **冲突解决方法**：冲突解决方法决定了发生碰撞时如何处理。常见的冲突解决方法包括链地址法（Chaining）、开放寻址法（Open Addressing）等，不同的方法对散列表的性能有不同的影响。

   4. **散列表的大小**：散列表大小直接影响到哈希冲突的频率和解决碰撞的效率。

   5. **哈希表的实现细节**：实现细节如桶的设计、哈希表的动态调整策略等也会影响其性能。

      ![61127a07b69c2f0adec8c57463763a0](C:\Users\ARENA TANG\Documents\WeChat Files\wxid_3stmcahx6b2511\FileStorage\Temp\61127a07b69c2f0adec8c57463763a0.png)

### 递归：

1. 一个递归算法必须包括终止条件和递归部分

2. 回溯算法的核心思想是:从根结点出发,沿着某条路径向前搜索,当搜索到某一结点发现不满足要求时,就返回(回溯)到上一结点,继续尝试其他路径。回溯算法不需要使用队列来保存路径,而是通过递归调用、返回上一层等方式来实现状态的保存和恢复。

   

### 队列：

尾进头出，要求进出的复杂度都是O(1)

无论哪种循环队列，都需要始终要留出一个空的队头元素（在queue中浪费一个位置的存储空间，以便区分队满和队空的情况）

**rear和front有一个空的时候：**

判空条件：front=rear

判满条件：(rear+ 1) % capacity == front

通过r和f找元素个数的公式：（rear-front+capacity）%capacity

**rear和front分别指向队头/队尾的情况：**

找元素个数：（rear-front+1+capacity）%capacity

判满条件：（rear+2）%capacity==front

判空条件：front=（rear+1）%capacity



循环队列

![image-20240618115644679](C:\Users\ARENA TANG\AppData\Roaming\Typora\typora-user-images\image-20240618115644679.png)

![image-20240618115456270](C:\Users\ARENA TANG\AppData\Roaming\Typora\typora-user-images\image-20240618115456270.png)

![image-20240618115502117](C:\Users\ARENA TANG\AppData\Roaming\Typora\typora-user-images\image-20240618115502117.png)

![image-20240618115506039](C:\Users\ARENA TANG\AppData\Roaming\Typora\typora-user-images\image-20240618115506039.png)

### DP动态规划：

解题思路：①1将原问题分解为子问题把原问题分解为若干个子问题，子问题和原问题形式相同或类似，只不过规模变小了。问题的解一旦求出就会被保存，所以每个子问题只需求解一次。

②确定状态，将和子问题相关的各个变量的一组取值，称为一个“状态”。一个“状态”对应于一个或多个子问题，所谓某个“状态”下的“值”，就是这个“状态”所对应的子问题的解。

③所有“状态”的集合，构成问题的“状态空间”。“状态空间”的大小，与用动态规划解决问题的时间复杂度直接相关。在数字三角形的例子里，一共有N×(N+1)/2个数字，所以这个问题的状态空间里一共就有N×(N+1)/2个状态。	       

时间复杂度：状态数目乘以计算每个状态所需时间

④确定状态转移方程

能用dp解决的题目特点：

①问题具有最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质。

②无后效性。当前的若干个状态值一旦确定，则此后过程的演变就只和这若干个状态的值有关，和之前是采取哪种手段或经过哪条路径演变到当前的这若干个状态，没有关系。

### 堆：

![image-20240618124306512](C:\Users\ARENA TANG\AppData\Roaming\Typora\typora-user-images\image-20240618124306512.png)

性质：

堆顶元素是优先级最高的(啥叫优先级高可自定义）

堆中的任何一棵子树都是堆

往堆中添加一个元素，并维持堆性质，复杂度O(log(n))

删除堆顶元素，剩余元素依然维持堆性质，复杂度O(log(n))

在无序列表中原地建堆，复杂度O(n)

作用：

①堆用于需要经常从一个集合中取走(即删除)优先级最高元素，而且还要经常往集合中添加元素的场合(堆可以用来实现优先队列）

②可以用堆进行排序，复杂度O(nlog(n))，且只需要O(1)的额外空间,称为“堆排序”。递归写法需要o(log(n))额外空间，非递归写法需要O(1)额外空间。

操作：

①插入：放到尾巴后再上浮

假设堆存放在列表a中，长度为n添加元素x到列表a尾部，使其成为a[n]

若x优先级高于其父结点，则令其和父结点交换，直到x优先级不高于其父结点，或x被交换到a[0]，变成堆顶为止。

停止交换后，新的堆形成，长度为n+1

时间复杂度：

由于n个元素的完全二叉树高度为log2(n+1)向上取整，每交换一次x就上升一层，因此上移操作复杂度O(log(n))，即添加元素复杂度O(log(n)）

②删除堆顶元素：先和堆尾元素交换，然后pop掉堆尾的元素，再把当前堆顶的元素下沉

时间复杂度有：下移过程复杂度为O(log(n))，因此删除堆顶元素复杂度O(log(n))

③建堆：一个长度为n的列表a,要原地将a变成一个堆

方法：将a看作一个完全二叉树。假设有H层。根在第0层，第H-1层都是叶子。

对第H-2层的每个元素执行下移操作

对第H-3层的每个元素执行下移操作.....

对第0层的元素执行下移操作。堆即建好。复杂度O(n)。

```python
class BinHeap:
    def __init__(self):
        self.heapList = [0]
        self.currentSize = 0

    def percUp(self, i):
        while i // 2 > 0:
            if self.heapList[i] < self.heapList[i // 2]:
                tmp = self.heapList[i // 2]
                self.heapList[i // 2] = self.heapList[i]
                self.heapList[i] = tmp
            i = i // 2

    def insert(self, k):
        self.heapList.append(k)
        self.currentSize = self.currentSize + 1
        self.percUp(self.currentSize)

    def percDown(self, i):
        while (i * 2) <= self.currentSize:
            mc = self.minChild(i)
            if self.heapList[i] > self.heapList[mc]:
                tmp = self.heapList[i]
                self.heapList[i] = self.heapList[mc]
                self.heapList[mc] = tmp
            i = mc

    def minChild(self, i):
        if i * 2 + 1 > self.currentSize:
            return i * 2
        else:
            if self.heapList[i * 2] < self.heapList[i * 2 + 1]:
                return i * 2
            else:
                return i * 2 + 1

    def delMin(self):
        retval = self.heapList[1]
        self.heapList[1] = self.heapList[self.currentSize]
        self.currentSize = self.currentSize - 1
        self.heapList.pop()
        self.percDown(1)
        return retval

    def buildHeap(self, alist):
        i = len(alist) // 2
        self.currentSize = len(alist)
        self.heapList = [0] + alist[:]
        while (i > 0):
            #print(f'i = {i}, {self.heapList}')
            self.percDown(i)
            i = i - 1
        #print(f'i = {i}, {self.heapList}')


n = int(input().strip())
bh = BinHeap()
for _ in range(n):
    inp = input().strip()
    if inp[0] == '1':
        bh.insert(int(inp.split()[1]))
    else:
        print(bh.delMin())
```

重要结论：如果a[i]的两棵子树都是堆，则对a[i]的下移操作完成后，以新a[i]为根的子树会形成堆。

### 栈：

![image-20240618125903640](C:\Users\ARENA TANG\AppData\Roaming\Typora\typora-user-images\image-20240618125903640.png)

##### 6.栈

###### 单调栈：可以找到第一个比当前节点高的节点的位置

```python
# 
n=int(input())
a=list(map(int,input().split()))


def monotonic_stack(nums):
    stack = []
    result = [str(0)] * len(nums)

    for i in range(len(nums)):
        # 当栈非空且当前元素比栈顶元素大时，出栈并更新结果
        while stack and nums[i] > nums[stack[-1]]:
            result[stack.pop()] = str(i+1)

        # 将当前元素的索引入栈
        stack.append(i)

    return result
print(' '.join(monotonic_stack(a)))




```

###### 波兰表达式（前缀表达式）

```python
# 波兰表达式是一种把运算符前置的算术表达式，例如普通的表达式2 + 3的波兰表示法为+ 2 3。波兰表达式的优点是运算符之间不必有优先级关系，也不必用括号改变运算次序，例如(2 + 3) * 4的波兰表示法为* + 2 3 4。本题求解波兰表达式的值，其中运算符包括+ - * /四个。
#原理：从后往前遍历，依次把数字放入栈中，遇到一个运算符就从栈顶弹出两个数字进行运算然后再将结果压入栈中。
a=input().split()
s=[]#存储运算符
n=[]#存储数字
for i in range(len(a)):
    x=a.pop()
    if x=='+' or x=='-' or x=='*' or x=='/':
        s.append(x)
        y = n.pop()
        z = n.pop()
        k = s.pop()
        if k == '+':
            n.append(y + z)
        elif k == '-':
            n.append(y-z)
        elif k == '*':
            n.append(y * z)
        elif k == '/':
            n.append(y/z)

    else:
        n.append(float(x))

ans=n[0]
print("{:.6f}".format(ans))


#逆波兰表达式（后缀表达式）
stack=[]
for t in s:
    if t in '+-*/':
        b,a=stack.pop(),stack.pop()
        stack.append(str(eval(a+t+b)))
    else:
        stack.append(t)
print(f'{float(stack[0]):.6f}')
```

###### 中序表达式转后序表达式：shunting yard调度场算法

原理：从前往后遍历中缀表达式，如果遇到数字就直接放入output，遇到左括号就入栈，遇到右括号就弹出到output直到遇到左括号，遇到运算符时：如果栈顶是运算符且优先级大于等于该运算符，则一直弹出直到优先级小于该运算符，然后再将当前运算符入栈。

遍历完后把栈中剩余元素加到output里

```python
# 
def infix_to_postfix(expression):
    precedence = {'+':1, '-':1, '*':2, '/':2}
    stack = []
    postfix = []
    number = ''

    for char in expression:
        if char.isnumeric() or char == '.':
            number += char
        else:
            if number:
                num = float(number)
                postfix.append(int(num) if num.is_integer() else num)
                number = ''
            if char in '+-*/':
                while stack and stack[-1] in '+-*/' and precedence[char] <= precedence[stack[-1]]:#判断优先级
                    postfix.append(stack.pop())#优先级大于等于当前运算符的全部出栈
                stack.append(char)#最后再入栈
            elif char == '(':
                stack.append(char)
            elif char == ')':
                while stack and stack[-1] != '(':
                    postfix.append(stack.pop())
                stack.pop()

    if number:
        num = float(number)
        postfix.append(int(num) if num.is_integer() else num)

    while stack:
        postfix.append(stack.pop())

    return ' '.join(str(x) for x in postfix)

n = int(input())
for _ in range(n):
    expression = input()
    print(infix_to_postfix(expression))
```

###### 快速堆猪：辅助栈

根本思路是辅助栈中存储当前栈中的最小值。每次执行 push 操作时，如果新元素比辅助栈中的栈顶元素更小，则将新元素也压入辅助栈；否则，将辅助栈栈顶元素再次压入辅助栈。这样，辅助栈的栈顶元素始终是当前栈中的最小值。

如果pop出的是最小值，说明最小值刚被压入栈中，此时辅助栈的栈顶就是最小值，第二个元素是第二小的值，因此即使pop出来最小值之后通过代码逻辑也可以保证辅助栈栈顶还是此时栈中的最小元素，非常巧妙，原因是在每次push的时候都相应push一个元素进辅助栈，使得辅助栈与标准栈始终保持一一对应的关系。
